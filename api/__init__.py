import json
from urllib import request


ROOT_URL = "https://jsonplaceholder.typicode.com/"


def get_todos(count=200):
    """
    Gets `count` number of todo items (Max: 200).

    Parameters
    ----------
    count: int, Default=200
        The number of todos to get. Defaults to 200.

    Returns
    -------
    list: dict { "userId": int, "id": int, "title": str, "completed": bool }
        A list of todo items of length = `count`.

    Raises
    ------
    ValueError
        If `count` is not an integer between 1 and 200.
    URLError
        If the request fails.
    """

    try:
        count = int(count)

        if count > 200:
            raise ValueError()
        elif count < 1:
            raise ValueError()
    except (ValueError, TypeError):
        raise ValueError("Count must be an integer between 1 and 200.")

    # Defining HTTP request.
    req = request.Request(f"{ROOT_URL}/todos?_limit={count}", method="GET")
    req.add_header("Content-Type", "application/json; charset=utf-8")

    # Making request and saving response.
    # Assumes the statement will throw an error if the request fails, send downstream.
    resp = request.urlopen(req)
    resp_decoded = resp.read().decode("utf-8")

    return json.loads(resp_decoded)


def create_todo(userId, title, completed=False):
    """
    Creates a todo item.

    Parameters
    ----------
        userId: int
            The id of the user who owns the todo item.
        title: str
            The title of the todo item.
        completed: bool, Default=False
            Whether or not the todo item is completed.

    Returns
    -------
        todo: dict { "userId": int, "id": int, "title": str, "completed": bool }
            The todo item that was created, including the autogenerated id.
    Raises
    -------
    ValueError
        If `userId` is not an integer.
        If `completed` is not a bool.
        If `title` is an empty string.
    URLError
        If the request fails.
    """

    try:
        userId = int(userId)
    except (ValueError, TypeError):
        raise ValueError(f"User ID must be an integer, not type: {type(userId)}.")

    if type(completed) != bool:
        raise ValueError("Completed value must be a True or False.")

    if title == None or title == "":
        raise ValueError("Title cannot be empty.")

    # Converts dict to JSON string.
    content = json.dumps({"userId": userId, "title": title, "completed": completed})

    # Encodes string to utf-8
    content_encoded = content.encode()

    # Defining HTTP request.
    req = request.Request(f"{ROOT_URL}/todos", method="POST", data=content_encoded)
    req.add_header("Content-Type", "application/json; charset=utf-8")

    # Making request and saving response.
    # Assumes the statement will throw an error if the request fails.
    resp = request.urlopen(req)
    resp_decoded = resp.read().decode("utf-8")

    return json.loads(resp_decoded)


def delete_todo(todo_id):
    """
    Deletes a todo item from the API.

    Parameters
    ----------
        todo_id: int
            The id of the todo item to delete.

    Returns:
        dict: An empty dict upon successful deletion.

    Raises
    ------
        ValueError
            If `todo_id` is not an integer greater than 1.
        URLError
            If the request fails.
    """

    try:
        todo_id = int(todo_id)

        if todo_id < 1:
            raise ValueError()
    except (ValueError, TypeError):
        raise ValueError(f"Todo ID must be an integer greater than 1.")

    # Defining HTTP request.
    req = request.Request(f"{ROOT_URL}/todos/{todo_id}", method="DELETE")

    # Making request and saving response.
    # Assumes the statement will throw an error if the request fails.
    resp = request.urlopen(req)
    resp_decoded = resp.read().decode("utf-8")

    # Will always return a 200 response code regardless of success.
    return json.loads(resp_decoded)
